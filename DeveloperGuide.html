<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Debugger-based On-Target Testing: Developer Guide</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ams_dott_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Debugger-based On-Target Testing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Developer Guide </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#Dev_DottConcepts">DOTT Concepts</a><ul><li class="level2"><a href="#Dev_TargetHost">Target vs. Host</a></li>
<li class="level2"><a href="#Dev_ExecutionFlow">Test Execution Flow and Modes of Operation</a><ul><li class="level3"><a href="#Dev_HaltMode">Halt Mode - Component Testing</a></li>
<li class="level3"><a href="#Dev_FreeRunningMode">Free Running Mode - System Testing</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Dev_NewProject">Creating a new Test Project</a></li>
<li class="level1"><a href="#Dev_TestExecution">Test Execution</a><ul><li class="level2"><a href="#Dev_Jenkins">Jenkins Integration</a></li>
<li class="level2"><a href="#Dev_GdbInvocation">GDB Server Invocation Strategy</a></li>
</ul>
</li>
<li class="level1"><a href="#Dev_WritingTests">Writing Tests</a><ul><li class="level2"><a href="#Dev_TargetExecution">Controlling target execution</a></li>
<li class="level2"><a href="#Dev_CallingTargetFunctions">Calling Target Functions</a></li>
<li class="level2"><a href="#Dev_TargetMemoryAccess">Reading an Writing Target Memory</a></li>
<li class="level2"><a href="#Dev_MemoryPerformance">Improving Target Memory Access Performance</a></li>
<li class="level2"><a href="#Dev_LiveAccess">Live Access to Target Memory</a></li>
<li class="level2"><a href="#Dev_BreakpointVariants">Breakpoint Variants and Data Injection</a></li>
<li class="level2"><a href="#Dev_InterruptDrivenFirmware">Dealing with Interrupt-driven Firmware</a></li>
<li class="level2"><a href="#Logging">Logging</a></li>
<li class="level2"><a href="#Dev_CompilerOptimization">Compiler Optimization</a></li>
</ul>
</li>
<li class="level1"><a href="#Dev_BuildSystem">Re-building the Example Target Firmware and DOTT Library</a></li>
<li class="level1"><a href="#Dev_ConfTest">DOTT Configuration Reference</a><ul><li class="level2"><a href="#Dev_DottIni">DOTT Ini / DottConf  Settings</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="Dev_DottConcepts"></a>
DOTT Concepts</h1>
<p>Before reading this section, it is assumed that you have already read the <a class="el" href="ComponentTesting.html">Component</a> and <a class="el" href="SystemTesting.html">System Test</a> sections. The developer's guide build on the information form these sections and provides additional technical background which shall enable DOTT users to apply and adapt DOTT for their projects.</p>
<h2><a class="anchor" id="Dev_TargetHost"></a>
Target vs. Host</h2>
<p>As a general rule, the DOTT framework uses the notion of <b>target</b> <em>firmware/functions/code/...</em> to refer to all code that is executed on the embedded target device. Likewise, <b>host</b> <em>functions/code/tests/...</em> is used for all code executed on the test host. This separation manifests itself throughout the framework where components such as examples are divided into <b>target</b> and <b>host</b> parts (most often by dedicated target and host folders).</p>
<h2><a class="anchor" id="Dev_ExecutionFlow"></a>
Test Execution Flow and Modes of Operation</h2>
<p>The typical sequence of steps when executing a test using DOTT is as follows:</p>
<ol type="1">
<li>The target gets halted.</li>
<li>The target firmware is loaded onto the target device.</li>
<li>The target is reset.</li>
<li>The target starts to execute until it reaches a special location (<b>DOTT test hook</b>) which is typically called form the application's main function. The target is halted at this location.</li>
<li>Control is passed to the implementation of the current test.</li>
<li>In the test, target functions can be called (see <a class="el" href="DeveloperGuide.html#Dev_HaltMode">halt mode</a>) or target execution can be resumed while providing external stimuli and inspecting target state at defined locations (see <a class="el" href="DeveloperGuide.html#Dev_FreeRunningMode">free running mode</a>). At the end of the test, the sequence starts over of for the next test.</li>
</ol>
<p>Which actions are performed before a test is executed (e.g., target reset) are specified for individual tests by means of <em>PyTest fixtures</em>. In the following example, two fixtures are used: <em>target_load</em> and <em>target_reset</em>. </p><div class="fragment"><div class="line">def test_SystickRunning(self, target_load, target_reset):</div><div class="line">    # ...</div></div><!-- fragment --><p> Note that in the PyTest configuration file <em>conftest.py</em> in the examples folder, the <em>target_load</em> and <em>target_reset</em> fixtures are re-directed to <em>target_load_flash</em> and <em>target_reset_flash</em>. This means that the target firmware is loaded into FLASH memory and, after reset, execution is performed from FLASH. Likewise, DOTT provides two fixtures called <em>target_load_sram</em> and <em>target_reset_sram</em> for SRAM firmware loading and execution. Additional, project-specific fixtures can easily be added to conftest.py. It is, for example, recommended to implement target access via external interfaces (e.g., I2C) via a fixture and to use this fixture in the tests. With such abstract communication fixtures, communication interface changes (e.g., using SPI instead of I2C) can easily be propagated to all tests without changing the tests themselves. <br />
 </p>
<h3><a class="anchor" id="Dev_HaltMode"></a>
Halt Mode - Component Testing</h3>
<p>For component testing, DOTT is typically used in 'halt mode' where the target is reset, a binary is downloaded to the target, the target is booted up and then halted in a specific location (typically the DOTT 'test hook'). In this state, DOTT passes control to a test implemented in PyTest. The following figure shows the halt mode style test execution.</p>
<div class="image">
<object type="image/svg+xml" data="dott_flow_halt.svg" width="580px"></object>
</div>
<h3><a class="anchor" id="Dev_FreeRunningMode"></a>
Free Running Mode - System Testing</h3>
<p>The 'free running' test mode starts the same way as a halt mode test by halting the target, downloading a firmware binary to the target and booting the target. It also hits the DOTT 'test hook' where it passes control to the test runner on the host. Instead of halting the target and then calling selected target functions as in halt mode, the target is allowed to run freely. Before resuming target execution, one or more halt points are set up. Once the target is running, stimuli are provided via the target's public communication interfaces (e.g., I2C, SPI). When one of the halt points is hit, the host-side test can inspect the target's internal state and compare it against the expected state (based on the stimuli provided via the external interface).</p>
<div class="image">
<object type="image/svg+xml" data="dott_flow_free.svg" width="580px"></object>
</div>
<h1><a class="anchor" id="Dev_NewProject"></a>
Creating a new Test Project</h1>
<p>The recommended way to set up a new DOTT-based test project is to start with a template project which you then customize to your need. To do so please follow these steps:</p><ol type="1">
<li>Copy the host folder from the 'standard' template from the templates folder as included in the DOTT docu and examples zip from the <a href="https://github.com/ams-ag/dott/releases">GitHub releases page</a> to your desired location.</li>
<li>In host/dott.ini customize at least the following entries:<ol type="a">
<li><b>app_load_elf</b> shall point to the location of the ELF-wrapped binary as downloaded to the target</li>
<li><b>app_symbol_elf</b> shall point to the ELF file which contains all the debug information</li>
<li><b>device_name</b> shall be the device name as specified in <em>JLinkDevices.xml</em></li>
</ol>
</li>
</ol>
<p>Note: A full list of dott.ini file options is provided <a class="el" href="DeveloperGuide.html#Dev_DottIni">here</a>.</p>
<h2>Preparing Target Firmware for DOTT</h2>
<p>To use DOTT in a firmware project the following steps have to be executed.</p>
<ul>
<li>Link the DOTT test-helper (<em>target/build/dott_library.a</em>) to the project. Alternatively you may want to compile and link <code>testhelpers.c</code> with your firmware project.</li>
<li>From the firmware's main function call the DOTT test hook: <div class="fragment"><div class="line">int main(void)</div><div class="line">{</div><div class="line">   DOTT_test_hook();</div><div class="line"></div><div class="line">   /* rest of main */</div><div class="line">}</div></div><!-- fragment --></li>
<li>Build your project and make sure that you create an ELF (axf) file with full debug symbols (<em>-gdwarf-4</em>). Note that the debug symbols are only used by the host and do not affect target binary size.</li>
<li>Create a BIN file of your target firmware. To be loaded via GDB into the target's memory the BIN file needs to be wrapped into an ELF file. This can be achieved using the <em>arm-none-eabi-objcopy</em> command which is included, e.g., in th <a href="https://developer.arm.com/tools-and-software/open-source-software/developer-tools/gnu-toolchain/gnu-rm">GNU Arm Embedded Toolchain</a>. For details see the Makefiles included with the DOTT example projects.</li>
<li>In <em>DOTT_test_hook</em> (<em>testhelpers.c</em>) a variable called <em>dbg_mem_u32</em> is defined (on stack) which is used by DOTT for on-target memory allocation in halt mode. By default this memory consist of 64 32bit words (256 bytes). This is usually sufficient but can be adjusted. Note that the dott target library needs to be re-compiled when adjusting this memory size.</li>
</ul>
<p>To simplify the steps outlined above, a basic template project (<em>templates/standard</em>) is included with DOTT. It includes minimal target firmware for a Cortex-M0 device where the DOTT test hook is called from the main. On the host side it includes a test which reads the Systick counter and checks if it properly increments. <br />
 </p>
<h1><a class="anchor" id="Dev_TestExecution"></a>
Test Execution</h1>
<p>Test execution is performed using <a href="http://www.pytest.org">PyTest</a> as test runner. For basic test execution, open a Python command prompt (and activate the DOTT venv if using a virtual environment). In the command prompt navigate to the folder containing your tests and executed <em>pytest</em>. PyTest will then collect all tests in this folder (and its sub-folders) and execute them. To list all found tests use the <b>&ndash;collect-only</b> argument:</p>
<div class="fragment"><div class="line">&gt; pytest --collect-only</div><div class="line">============================= test session starts =============================</div><div class="line">collected 10 items</div><div class="line">&lt;Module <span class="stringliteral">&#39;02_system_testing/host/test_cntr.py&#39;</span>&gt;</div><div class="line">  &lt;Class <span class="stringliteral">&#39;TestCounters&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_SystickRunning&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_SystickRunningLive&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_TimerRunning&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_TimerManualIrq&#39;</span>&gt;</div><div class="line">&lt;Module <span class="stringliteral">&#39;02_system_testing/host/test_i2c_comm.py&#39;</span>&gt;</div><div class="line">  &lt;Class <span class="stringliteral">&#39;TestI2cCommunication&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_RegWriteRead&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_CmdAdd&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_CmdUnknown&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_CmdInjectUnknown&#39;</span>&gt;</div><div class="line">&lt;Module <span class="stringliteral">&#39;02_system_testing/host/test_sysinit.py&#39;</span>&gt;</div><div class="line">  &lt;Class <span class="stringliteral">&#39;TestSystemInit&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_sysinit_bss_section&#39;</span>&gt;</div><div class="line">      &lt;Function <span class="stringliteral">&#39;test_sysinit_data_section&#39;</span>&gt;</div></div><!-- fragment --><p>To execute only selected tests instead of all tests used the <b>-k</b> argument. The following example executes all tests which have 'Systick' in their name:</p>
<div class="fragment"><div class="line">&gt; pytest -k Systick</div></div><!-- fragment --><p>In addition to this basic string-based filtering, PyTest supports custom markers for tests using the <b>@pytest.mark</b> decorator. PyTest allows users to define arbitrary markers and individual tests can carry multiple such markers. For example, the following test has a marker <em>irq_testing</em>:</p>
<div class="fragment"><div class="line">@pytest.mark.irq_testing</div><div class="line"><span class="keyword">def </span>test_TimerManualIrq(self, target_load, target_reset, live_access):</div><div class="line">    <span class="comment"># ...</span></div><div class="line">    <span class="comment"># ...    </span></div></div><!-- fragment --><p>To execute all tests with the <em>irw_testing</em> marker you can now invoke pytesst with the <b>-m</b> argument:</p>
<div class="fragment"><div class="line">&gt; pytest -m irq_testing</div></div><!-- fragment --><h2><a class="anchor" id="Dev_Jenkins"></a>
Jenkins Integration</h2>
<p>To run DOTT-based tests in a <b>Jenkins</b> environment, activate the DOTT venv. In a Jekinsfile 'bat' section this can be done as follows:</p>
<div class="fragment"><div class="line">bat &#39;&#39;&#39;</div><div class="line">    call c:\\YOUR_PATH\\dott_venv\Scripts\activate.bat</div><div class="line">    cd YOUR_TEST_FOLDER</div><div class="line">    pytest</div><div class="line"></div><div class="line">    REM ...</div><div class="line"></div><div class="line">    &#39;&#39;&#39;</div></div><!-- fragment --><h2><a class="anchor" id="Dev_GdbInvocation"></a>
GDB Server Invocation Strategy</h2>
<p>DOTT requires a J-LINK GDB server to interact with the target. There are two options to start the GDB server. First, J-Link GDB server is started manually. When doing so you will see a window as shown below. In this cases you need to specify the IP address of your machine using the <b>gdb_server_addr</b> option in <a class="el" href="DeveloperGuide.html#Dev_DottIni">dott.ini</a>. Note that this allows you also to configure DOTT to connect to a remote GDB server.</p>
<div class="image">
<img src="gdb_server_status.png" alt="gdb_server_status.png"/>
<div class="caption">
GDB server window for GDB connected to the reference board.</div></div>
<p> The second option is to use the GDB server 'auto-start' feature of DOTT. If there is no <b>gdb_server_addr</b> option specified in <a class="el" href="DeveloperGuide.html#Dev_DottIni">dott.ini</a> (or <a class="el" href="DeveloperGuide.html#Dev_ConfTest">DOTT Configuration Reference</a>} "conftest.py") then DOTT tries to auto start the J-Link GDB server. If <b>gdb_server_binary</b> is not specified in <a class="el" href="DeveloperGuide.html#Dev_DottIni">dott.ini</a>, DOTT assumes to find the J-Link GDB server in its default install location.</p>
<h1><a class="anchor" id="Dev_WritingTests"></a>
Writing Tests</h1>
<p>This section describes how to write tests using DOTT. Tests are implemented in PyTest and hence following the PyTest convention that test functions have to start with <b>test_</b> to be discovered by PyTest:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_MyFirstOne(target_load_flash, target_reset_flash):</div><div class="line">    <span class="comment"># ...</span></div></div><!-- fragment --><p>In addition, tests can be grouped using classes and modules.</p>
<p>What you can also see in the above example is that the test takes two test fixtures. In contrast to other test framework where you have dedicated setup/teardown methods for controlling your test environment PyTest uses fixtures. DOTT comes with the following built-in fixtures:</p>
<ul>
<li><b>target_load_sram</b>: Load firmware binary into target SRAM. Loading is performed per test (and not per session).</li>
<li><b>target_load_flash</b>: Load firmware binary into target FLASH. Loading is performed per test session (and not per test).</li>
<li><b>target_load_flash_always</b>: Load the application binary to the target on a per-test basis (vs. target_load_flash which only loads once per test session)</li>
<li><b>target_reset_sram</b>: Reset the target and prepare it to execute from SRAM (at address 0x20000000).</li>
<li><b>target_reset_flash</b>: Reset target and prepare it to execute from FLASH.</li>
<li><b>target_load_symbols_only</b>: Load application symbols but do not perform target download.</li>
<li><b>live_access</b>: Allows to access target memory while the target is running.</li>
</ul>
<p>Custom fixtures can be easily added in a project-specific <a class="el" href="DeveloperGuide.html#Dev_ConfTest">conftest.py</a>. For convenience, the <em>conftest.py</em> in the examples aliases <em>target_load_flash</em> to <b>traget_load</b> and <em>target_reset_flash</em> to <b>target_reset</b>. This convention is also used throughout the examples in this document.</p>
<h2><a class="anchor" id="Dev_TargetExecution"></a>
Controlling target execution</h2>
<p>When a test which uses <em>target_load</em> and <em>target_reset</em> fixtures is entered, the binary has already been loaded to the target, the target was reset and execution was started and finally the target was halted at the location of the DOTT test hook. It must be emphasized that the target is <b>not running when entering a test</b>. Target execution can be continued with <b>cont()</b> and halted again with <b>halt()</b> as shown below:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_MyFirstOne(target_load_flash, target_reset_flash):</div><div class="line">    <span class="comment"># target is halted in DOTT test hook</span></div><div class="line"></div><div class="line">    <span class="comment"># let target run (continue execution)</span></div><div class="line">    dott().target.cont()</div><div class="line"></div><div class="line">    <span class="comment"># wait some time...</span></div><div class="line"></div><div class="line">    <span class="comment"># halt the target again</span></div><div class="line">    dott().target.halt()</div><div class="line"></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> dott().target.is_running():</div><div class="line">        <span class="comment"># Oops - somthing went wrong. Target should be halted...</span></div></div><!-- fragment --><p>With <b>target_is_running()</b> you can check if the target is currently running or not.</p>
<h2><a class="anchor" id="Dev_CallingTargetFunctions"></a>
Calling Target Functions</h2>
<p>DOTT allows you to call target functions while the target is halted:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_MyFirstOne(target_load_flash, target_reset_flash):</div><div class="line">    <span class="comment"># target is halted in DOTT test hook</span></div><div class="line"></div><div class="line">    dott().target.eval(<span class="stringliteral">&#39;MyTargetFunction(1, 55)&#39;</span>)    </div></div><!-- fragment --><p>If a function expects arguments which are not primitive types but pointers, structs, arrays etc. target memory needs to be allocated and filled with appropriate values before calling the function. DOTT supports this type of on-target memory allocation <b>while the target is halted in the DOTT test hook</b>. This is the case after entering the test <b>as long as target execution was not resumed</b> using <b>cont()</b>.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_MyFirstOne(target_load_flash, target_reset_flash):</div><div class="line">    <span class="comment"># target is halted in DOTT test hook</span></div><div class="line"></div><div class="line">    <span class="comment"># allocate a chunk 32 bytes of target memory</span></div><div class="line">    ptr = dott().target.mem.alloc(32)</div><div class="line"></div><div class="line">    <span class="comment"># more conventient: typed allocation; allocate memory for 2 uint32_t elements</span></div><div class="line">    ptr = dott().target.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, cnt=2)</div><div class="line">    <span class="comment"># set values and perform fucntion call</span></div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;{ptr}[0] = 9&#39;</span>)</div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;{ptr}[1] = 12&#39;</span>)</div><div class="line">    res = dott().target.eval(f<span class="stringliteral">&#39;example_AdditionPtr(&amp;{ptr}[0], &amp;{ptr}[1])&#39;</span>)</div><div class="line"></div><div class="line">    <span class="comment"># or directly set the vlaues as part of memory allocation</span></div><div class="line">    p_a = dott().target.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, val=9)</div><div class="line">    p_b = dott().target.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, val=12)</div><div class="line">    res = dott().target.eval(f<span class="stringliteral">&#39;example_AdditionPtr({p_a}, {p_b})&#39;</span>)</div><div class="line"></div><div class="line">    <span class="comment"># continue target execution. IMPORTANT: dott().target.mem.alloc* is not available beyond this point!</span></div><div class="line">    dott().target.cont()</div></div><!-- fragment --><h2><a class="anchor" id="Dev_TargetMemoryAccess"></a>
Reading an Writing Target Memory</h2>
<p>In DOTT there are multiple ways to access target memory. As a general rule, target memory can only be accessed while the target is halted (with the exception of <a class="el" href="DeveloperGuide.html#Dev_LiveAccess">target live access</a>). Using <b>eval()</b> individual (static) global target variables can be read or written as well as local variables which are int the scope where the target is currently halted. Depending on compiler optimization, some variables might no longer be accessible. Some tricks how to deal with such situations are given in the section on <a class="el" href="DeveloperGuide.html#Dev_CompilerOptimization">compiler optimization</a>.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_MyFirstOne(target_load_flash, target_reset_flash):</div><div class="line">    <span class="comment"># read the value of a global variable and write it back incremented by 1</span></div><div class="line">    val = dott().target.eval(<span class="stringliteral">&#39;some_global_var&#39;</span>)</div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;some_global_var = {val + 1}&#39;</span>)</div></div><!-- fragment --><p>An alternative way to read memory is the <b>target.mem</b> interface. In contract to eval, it is designed for bulk memory access and hence should be preferred in larger amounts of memory need to be transferred to/from the target.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_MyFirstOne(target_load_flash, target_reset_flash):</div><div class="line">    <span class="comment"># read an uint32_t array with 256 elements using mem.read</span></div><div class="line">    addr = dott().target.eval(<span class="stringliteral">&#39;my_array_var&#39;</span>)</div><div class="line">    val_bytes = dott().target.mem.read(addr, 256 * 4)</div><div class="line">    val_ints = DottConvert.bytes_to_uint32(val_bytes)</div><div class="line"></div><div class="line">    <span class="comment"># write elements to the above uint32_t array</span></div><div class="line">    elements = [0, 1, 2, 4, 5, 6, 7, 8, 10]</div><div class="line">    val_bytes = DottConvert.uint32_to_bytes(elements)</div><div class="line">    dott().target.mem.write(addr, val_bytes)</div></div><!-- fragment --><h2><a class="anchor" id="Dev_MemoryPerformance"></a>
Improving Target Memory Access Performance</h2>
<p>As shown in the previous section, DOTT offers two ways to access target memory: <em>eval()</em> and <em>mem.read() / mem.write()</em>. While <em>eval()</em> is mor convenient since it also allows direct access to, e.g., struct members its performance is relatively low since every <em>eval()</em> translates into a single USB transaction to the debug probe. In contrast to that <em>mem.read/write()</em> offers much better performance since memory access is performed in bulks. The following example shows how <em>eval</em> based access can be replaced with <em>mem.read/write</em> when dealing with a struct. Performance increase for this example is more than 8. The downside is that the target struct has to be replicated on the host using ctypes. If the declaration of the target struct changes, also the ctypes struct on the host needs to be updated. Note that also aspects such as struct packing and byte order need to be taken into account.</p>
<div class="fragment"><div class="line"><span class="keyword">import</span> ctypes</div><div class="line"></div><div class="line"><span class="comment"># test demonstrating struct filling using eval</span></div><div class="line"><span class="keyword">def </span>test_eval(self, target_load, target_reset):</div><div class="line">    p_dat = dott().target.mem.alloc_type(<span class="stringliteral">&#39;my_add_t&#39;</span>)</div><div class="line"></div><div class="line">    <span class="comment"># eval-based filling of on-target struct data</span></div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;paddA = {0xff}&#39;</span>)</div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;a = {0xaabbccdd}&#39;</span>)</div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;paddB = {0x0}&#39;</span>)</div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;b = {0xdeadbeef}&#39;</span>)</div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;paddC = {0x0}&#39;</span>)</div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;sum = {0x60}&#39;</span>)</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"># test demonstrating struct filling using mem.write and ctypes </span></div><div class="line"><span class="keyword">def </span>test_ctypes(self, target_load, target_reset):</div><div class="line">    <span class="comment"># Arm Compiler struct packing notes:</span></div><div class="line">    <span class="comment"># https://developer.arm.com/docs/100748/latest/writing-optimized-code/packing-data-structures</span></div><div class="line">    <span class="comment"># see ctypes _pack_ attribute for configuration details</span></div><div class="line"></div><div class="line">    <span class="comment"># replicate struct on host using ctypes</span></div><div class="line">    <span class="keyword">class </span>HOST_my_add_t(ctypes.LittleEndianStructure):</div><div class="line">        _pack_ = 0</div><div class="line">        _fields_ = [(<span class="stringliteral">&#39;paddA&#39;</span>, ctypes.c_uint8),</div><div class="line">                    (<span class="stringliteral">&#39;a&#39;</span>, ctypes.c_uint32),</div><div class="line">                    (<span class="stringliteral">&#39;paddB&#39;</span>, ctypes.c_uint8),</div><div class="line">                    (<span class="stringliteral">&#39;b&#39;</span>, ctypes.c_uint32),</div><div class="line">                    (<span class="stringliteral">&#39;paddC&#39;</span>, ctypes.c_uint8),</div><div class="line">                    (<span class="stringliteral">&#39;sum&#39;</span>, ctypes.c_uint32)</div><div class="line">                    ]</div><div class="line"></div><div class="line">    <span class="comment"># ctypes and mem write based filling of on-target struct data</span></div><div class="line">    tmp = HOST_my_add_t(paddA=0xff, a=0xaabbccdd, paddB=0, b=0xdeadbeef, paddC=0, sum=0x60)</div><div class="line">    tmp_bytes = bytes(tmp)</div><div class="line">    p_dat = dott().target.mem.alloc(len(tmp_bytes))</div><div class="line">    dott().target.mem.write(p_dat, tmp_bytes)</div></div><!-- fragment --><h2><a class="anchor" id="Dev_LiveAccess"></a>
Live Access to Target Memory</h2>
<p>In addition to target memory access while the target is halted, DOTT allows basic access to target memory while the target is running. This can be useful to monitor (and sometimes plot) target variables/state which might be difficult to monitor (e.g., in a system heavily relying on interrupts halting and reading target memory could severely mess up timing).</p>
<p>To make use of live access, add the <b>live_access</b> fixture to the test as shown below. Currently, the live_access feature has a rather limited interface consisting of just two functions namely <em>mem_read_u32</em> and <em>mem_write_u32</em>. <br />
 The following example code demonstrates how to read the SysTick counter using live access and generate a plot using <em>matplotlib</em> which is stored as a png file.</p>
<div class="fragment"><div class="line"><span class="comment"># code snippet form examples/02_system_testing/test_cntr.py</span></div><div class="line"></div><div class="line"><span class="keyword">def </span>test_SystickSampleLive(self, target_load, target_reset, live_access):</div><div class="line">    <span class="keyword">def </span>sample_mem_addr(mem_addr: int, duration: float, live: TargetLive) -&gt; (List[float], List[int]):</div><div class="line">        duration_list: List[float] = []</div><div class="line">        samples_list: List[int] = []</div><div class="line">        time_start = time.time()</div><div class="line">        <span class="keywordflow">while</span> (time.time() - time_start) &lt; duration:</div><div class="line">            duration_list.append(time.time() - time_start)</div><div class="line">            samples_list.append(live.mem_read_32(mem_addr))</div><div class="line"></div><div class="line">        <span class="keywordflow">return</span> duration_list, samples_list</div><div class="line"></div><div class="line">    dott().target.cont()</div><div class="line"></div><div class="line">    addr = dott().target.eval(<span class="stringliteral">&#39;&amp;_tick_cnt&#39;</span>)</div><div class="line">    (host_time, msecs_samples) = sample_mem_addr(addr, 1.0, live_access)</div><div class="line"></div><div class="line">    dott().target.halt()</div><div class="line"></div><div class="line">    <span class="comment"># plot the data samples from the target</span></div><div class="line">    pyplot.clf()</div><div class="line">    pyplot.plot(host_time, msecs_samples)</div><div class="line">    pyplot.ylabel(<span class="stringliteral">&#39;systick&#39;</span>)</div><div class="line">    pyplot.xlabel(<span class="stringliteral">&#39;host runtime&#39;</span>)</div><div class="line">    pyplot.savefig(<span class="stringliteral">&#39;test_systick_sample_live&#39;</span>, dpi=200)</div><div class="line">    <span class="comment"># pyplot.show() # pops up the plot window - usually not wanted in automated tests</span></div></div><!-- fragment --><h2><a class="anchor" id="Dev_BreakpointVariants"></a>
Breakpoint Variants and Data Injection</h2>
<p>DOTT supports breakpoints to halt target execution when pre-defined locations are reached. More specifically, DOTT currently offers two different breakpoint variants which have specific use cases (and limitations): <b>HaltPoints</b> and <b>InterceptPoints</b>.</p>
<h3>HaltPoints</h3>
<p>A halt point comes very close to the behavior of a traditional break point. It can be placed at any accessible symbol of the target binary. When the location specified by the halt point is reached, the target is halted. A test can wait for this event by calling the <em>wait_complete()</em> method of the halt point instance which blocks until the halt point is reached. </p><div class="fragment"><div class="line"><span class="keyword">def </span>test_MyTest(self, target_load, target_reset):</div><div class="line">    hp = HaltPoint(<span class="stringliteral">&#39;app_main&#39;</span>)</div><div class="line">    dott().target.cont()</div><div class="line">    <span class="keywordflow">try</span>:</div><div class="line">        hp.wait_complete(timeout=5)</div><div class="line">    <span class="keywordflow">except</span> TimeoutError:</div><div class="line">        <span class="comment"># main was not reached within specified time - deal with it!</span></div><div class="line">        assert(<span class="keyword">False</span>)</div><div class="line"></div><div class="line">    <span class="comment"># target is now halted at beginning of main     </span></div></div><!-- fragment --><p> Note that it usually is a good practice to specify a timeout for wait_complete to avoid that a test gets stuck if a halt point is not reached as expected. A halt point also offers a <b>reached()</b> method which you can override: </p><div class="fragment"><div class="line"><span class="keyword">def </span>test_MyTest(self, target_load, target_reset):</div><div class="line">    <span class="keyword">class </span>MyHp(HaltPoint):</div><div class="line">        <span class="keyword">def </span>reached(self):</div><div class="line">            log.debug(<span class="stringliteral">&#39;Hello world - halt point reached!&#39;</span>)</div><div class="line"></div><div class="line">    hp = MyHp(<span class="stringliteral">&#39;app_main&#39;</span>)</div><div class="line">    dott().target.cont()</div><div class="line">    hp.wait_complete()</div></div><!-- fragment --><p> In the <b>reached()</b> method you have full access to all <em>dott().target</em> functions including memory access and target control meaning that you can also continue target execution. However there is one important limitation of a halt point: </p><blockquote class="doxtable">
<p><b>WARNING:</b> If a HaltPoint is hit while a target function is executed which was started using &gt;*dott().target.eval()*, the execution of this function is interrupted and can not be resumed. In situations where you want to use a breakpoint without altering the target's execution state use an InterceptPoint! </p>
</blockquote>
<h3>InterceptPoints</h3>
<p>InerceptPoints are breakpoints which allow you to access and modify target memory when they are reached without changing the execution state of the target. Specifically, currently ongoing function calls initiated via <em>dott().target.eval()</em> are not interrupted. This feature of InterceptPoints comes with a limitation: In the <em>reached()</em> method of an InterceptPoint <b>no calls to <em>dott().target</em> functions must be made!</b>. Instead, use the <em>eval()</em> and <em>ret()</em> methods of the InterceptPoint class to access target memory or let the target return from its currently executed function. Other functionality such as bulk memory access (functions from <em>dott().target.mem</em> are also not available in InterceptPoints). The following code snippet shows how to use an InterceptPoint:</p>
<div class="fragment"><div class="line"><span class="comment"># code snippet form exampes/01_component_testing/test_example_functions.py</span></div><div class="line"></div><div class="line"><span class="keyword">def </span>test_example_AdditionSubcallsExtIntercept(self, target_load, target_reset):</div><div class="line"></div><div class="line">    <span class="keyword">class </span>BpA(InterceptPoint):</div><div class="line">        <span class="keyword">def </span>reached(self):</div><div class="line">            self.ret(10)</div><div class="line"></div><div class="line">    <span class="keyword">class </span>BpB(InterceptPoint):</div><div class="line">        <span class="keyword">def </span>reached(self):</div><div class="line">            self.eval(<span class="stringliteral">&#39;*b = 89&#39;</span>)</div><div class="line">            self.eval(<span class="stringliteral">&#39;*b += 10&#39;</span>)</div><div class="line">            val = self.eval(<span class="stringliteral">&#39;*b&#39;</span>)</div><div class="line">            assert(val == 99)</div><div class="line">            self.ret(0)</div><div class="line"></div><div class="line">    bpa = BpA(<span class="stringliteral">&#39;example_GetA&#39;</span>)</div><div class="line">    bpb = BpB(<span class="stringliteral">&#39;example_GetB&#39;</span>)</div><div class="line"></div><div class="line">    res = dott().target.eval(<span class="stringliteral">&#39;example_AdditionSubcalls()&#39;</span>)</div><div class="line"></div><div class="line">    bpa.delete()</div><div class="line">    bpb.delete()</div><div class="line"></div><div class="line">    assert(109 == res)</div></div><!-- fragment --><p> In the example above, intercept points are create for target methods <em>example_GetA</em> and <em>example_GetB</em>. When the intercept points are reached the values returned by the function are altered and execution continues. Note that the function call to <em>example_AdditionSubcalls</em> performed via <em>eval()</em> is not interrupted as it would be if halt points would have been used.</p>
<h3>Breakpoints at Labels</h3>
<p>Halt- and InterceptPoints can be placed at every accessible symbol of the target binary and are triggered upon symbol invocation (i.e., function entry). A more versatile approach is to add DOTT_LABELs to you code which can also be used as Halt- and InterceptPoint locations. DOTT_LABELs can be placed anywhere in the code:</p>
<div class="fragment"><div class="line">#include &quot;testhelpers.h&quot;</div><div class="line">void example(void)</div><div class="line">{</div><div class="line">    /* other code here */</div><div class="line"></div><div class="line">    DOTT_LABEL(&quot;my_location&quot;)</div><div class="line"></div><div class="line">    /* even more code here */</div><div class="line">}</div></div><!-- fragment --><p>When creating a Halt- or InterceptPoint in the Python test code, the DOTT_LABEL can be specified:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_example(self, target_load, target_reset):</div><div class="line">    hp = HaltPoint(DOTT_LABEL(<span class="stringliteral">&#39;my_location&#39;</span>))</div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    dott().target.cont()</div><div class="line">    hp.wait_complete()</div><div class="line">    <span class="comment"># ...</span></div></div><!-- fragment --><h2><a class="anchor" id="Dev_InterruptDrivenFirmware"></a>
Dealing with Interrupt-driven Firmware</h2>
<p>When implementing system tests for heavily interrupt-driven firmware locations where Halt- and InterceptPoints are placed have to be chosen wisely as evey Halt- and InterceptPoint influences the target's timing behavior. Breakpoints should ideally only be placed after the events of interest have been fully handled by the target and when it is safe to halt the targeted.</p>
<p>If this is not possible or if it is desired to test functionality closely related to interrupts, a different approach can be employed. The basic idea is to disable the generation of interrupts by peripherals and instead control the generation of interrupts via DOTT. This way, the tests no longer have to deal with potentially (too) high interrupt frequency but interrupt generation can be adapted to a speed which can be handled by the tests.</p>
<p>The following example shows a simple test which checks if a timer on the target is incrementing:</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>test_TimerRunning(self, target_load, target_reset):</div><div class="line">    <span class="keyword">assert</span> (0 == dott().target.eval(<span class="stringliteral">&#39;_timer_cnt&#39;</span>)), <span class="stringliteral">&#39;Timer count shall initially be zero.&#39;</span></div><div class="line">    dott().target.cont()</div><div class="line">    time.sleep(1)</div><div class="line">    dott().target.halt()</div><div class="line">    <span class="keyword">assert</span> (0 &lt; dott().target.eval(<span class="stringliteral">&#39;_timer_cnt&#39;</span>)), <span class="stringliteral">&#39;Timer count should have advanced while target was running&#39;</span>   </div></div><!-- fragment --><p>If one now wants to test specific aspects of the interrupt handling code (e.g., by injecting data using an InterceptPoint) this would substantially change the target's timing behavior and hence, timer interrupts might be missed and results might be incorrect.</p>
<p>The following example shows an approach which overcomes this limitation by (1) disabling the timer and (2) manually generating timer interrupts by setting the timer's pending bit in the ISPR (interrupt set pending register). In addition, an InterceptPoint is set in the timer's interrupt handler which alters the timer count. The before generating the next manual interrupt, the test waits until the InterceptPoint is completed.</p>
<div class="fragment"><div class="line"><span class="comment"># code snippet from examples/02_system_testing/test_cntr.py</span></div><div class="line"></div><div class="line"><span class="keyword">def </span>test_TimerManualIrqAdvanced(self, target_load, target_reset, live_access):</div><div class="line">    APB1ENR = 0x4002101c  <span class="comment"># APB1 enable register</span></div><div class="line">    ISPR = 0xE000E200  <span class="comment"># interrupt set pending register</span></div><div class="line"></div><div class="line">    <span class="comment"># wait until the target has reached function app_main</span></div><div class="line">    hp = HaltPoint(<span class="stringliteral">&#39;app_main&#39;</span>)</div><div class="line">    dott().target.cont()</div><div class="line">    hp.wait_complete()</div><div class="line">    hp.delete()</div><div class="line"></div><div class="line">    <span class="comment"># Custom InterceptPoint which performs an additional counter increment.</span></div><div class="line">    <span class="keyword">class </span>MyIp(InterceptPoint):</div><div class="line">        <span class="keyword">def </span>reached(self):</div><div class="line">            self.eval(<span class="stringliteral">&#39;_timer_cnt++&#39;</span>)</div><div class="line"></div><div class="line">    ip_tmr = MyIp(DOTT_LABEL(<span class="stringliteral">&#39;TIM7_IRQHandler_End&#39;</span>))</div><div class="line"></div><div class="line">    <span class="comment"># disable the clock for TIM7 such that it does not fire anymore and reset the timer counter to zero</span></div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;*{APB1ENR} &amp;= ~0x20&#39;</span>)</div><div class="line">    dott().target.eval(<span class="stringliteral">&#39;_timer_cnt = 0&#39;</span>)</div><div class="line"></div><div class="line">    <span class="comment"># let target run and ensure that the timer counter is still zero</span></div><div class="line">    dott().target.cont()</div><div class="line">    time.sleep(1)</div><div class="line">    dott().target.halt()</div><div class="line">    timer_cnt = dott().target.eval(<span class="stringliteral">&#39;_timer_cnt&#39;</span>)</div><div class="line">    assert(0 == timer_cnt), <span class="stringliteral">&#39;Expected timer count to be 0&#39;</span></div><div class="line"></div><div class="line">    <span class="comment"># let target run again and via live target access set the TIM7 interrupt pending 4 times (i.e., &#39;manually&#39;</span></div><div class="line">    <span class="comment"># trigger the TIM7 interrupt)</span></div><div class="line">    dott().target.cont()</div><div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(4):</div><div class="line">        live_access.mem_write_32(ISPR, [0x000040000])</div><div class="line">        ip_tmr.wait_complete()</div><div class="line"></div><div class="line">    <span class="comment"># halt target and check that timer count actually is 8 (interrupt was raised 4 times but our intercept point</span></div><div class="line">    <span class="comment"># does an additional increment for _timer_cnt for each interrupt and hence the timer count should be 8)</span></div><div class="line">    dott().target.halt()</div><div class="line">    timer_cnt = dott().target.eval(<span class="stringliteral">&#39;_timer_cnt&#39;</span>)</div><div class="line">    assert(8 == timer_cnt), <span class="stringliteral">&#39;Expected timer count to be 8&#39;</span></div></div><!-- fragment --><h2><a class="anchor" id="Logging"></a>
Logging</h2>
<p>DOTT comes with its own logger with is using Python's logging facility. To access DOTT's logger import it as follows: </p><div class="fragment"><div class="line"><span class="keyword">from</span> dottmi.utils <span class="keyword">import</span> log</div><div class="line"></div><div class="line"><span class="keyword">def </span>test_LogTesting(self, target_load, target_reset):</div><div class="line">    log.debug(<span class="stringliteral">&#39;...&#39;</span>)</div></div><!-- fragment --><h2><a class="anchor" id="Dev_CompilerOptimization"></a>
Compiler Optimization</h2>
<p>High compiler optimization levels (e.g., O3 or Oz) and link-time optimization can substantially change the binary's structure versus the code's structure. This can make setting breakpoints or inspecting variable content difficult (if, e.g., some variables are optimized out entirely). To somewhat reduce these problems (usually on the expense of code size), DOTT comes with some macros which might be helpful to tweak the source code to enable/simplify test development.</p>
<p>With the <em>DOTT_NO_OPTIMIZE</em> macro a function can be excluded entirely from optimization: </p><div class="fragment"><div class="line">#include &quot;testhelpers.h&quot;</div><div class="line"></div><div class="line">uint32_t DOTT_NO_OPTIMIZE example(void)</div><div class="line">{</div><div class="line">    /* ... */</div><div class="line">}</div></div><!-- fragment --><p>With the <em>DOTT_NO_INLINE</em> macro a function be prevented from being inlined: </p><div class="fragment"><div class="line">#include &quot;testhelpers.h&quot;</div><div class="line"></div><div class="line">uint32_t DOTT_NO_INLINE example(void)</div><div class="line">{</div><div class="line">    /* ... */</div><div class="line">}</div></div><!-- fragment --><p>With <em>DOTT_VAR_KEEP</em> a variable, which would otherwise be optimized out by the compiler, can be preserved: </p><div class="fragment"><div class="line">#include &quot;testhelpers.h&quot;</div><div class="line"></div><div class="line">uint32_t example(void)</div><div class="line">{</div><div class="line">    /* ... */</div><div class="line"></div><div class="line">    DOTT_VAR_KEEP(var_name);</div><div class="line"></div><div class="line">    /* ... */</div><div class="line">}</div></div><!-- fragment --><p>Note that it is recommended to use the macros discussed above instead of directly using, .e.g., <code>__attribute__((noinline))</code>. The rationale is that DOTT comes with implementations of these macro for all compilers supported by DOTT.</p>
<h2>C++ Scope Resolution</h2>
<p>If the target project is a C++ project, some extra care must be taken related to the scope resolution operator (::). When, e.g., calling a method of a static class called <em>Bar</em> in namespace <em>Foo</em> this is done like this: </p><div class="fragment"><div class="line">dott().target.eval(&quot;&#39;Foo::Bar::my_function&#39;(...)&quot;</div></div><!-- fragment --><p> Please note that <em>single quotes</em> are required around namespace, class name and function name.</p>
<h2>Customize Target Connect Sequence</h2>
<p>If you need to customize the target connection sequence, DOTT provides hooks via the DootHooks class. Via this class you are able to specify callback hooks which are called by DOTT. To date, the following hooks ara available:</p>
<ul>
<li><b>pre_connect_hook</b> The registered hook callback function is invoked before DOTT attempts to connect to the target. This allows users to, e.g., enable the target's debug channel.</li>
</ul>
<h2>Segger J-Link FLASH cache</h2>
<p>The Segger JLINK software caches content of memory regions such as FLASH which it assumes to not change during runtime. However, this assumption might not be correct if, for example, the target uses an on-device bootloader to updated FLASH content via, e.g., I2C. This flash cache can be disabled as follows: </p><div class="fragment"><div class="line">dott().target.cli_exec(&#39;monitor exec ExcludeFlashCacheRange 0x08000000-0x09000000&#39;)</div></div><!-- fragment --><h1><a class="anchor" id="Dev_BuildSystem"></a>
Re-building the Example Target Firmware and DOTT Library</h1>
<p>The example firmware and the DOTT library for the target reference board is provided in binary and source code formats. The binaries enable users to directly run the examples without the need to first set up a build environment and compile the source code for the reference target. All native code comes with Makefiles and Arm Compiler 6 is used to compile the code.</p>
<p>To compile the code on the Windows command line, you need an environment which includes the <code>GNU make</code>, a shell such as <code>busybox</code> and the Arm Compiler 6 command line version. In such an environment, you can now navigate to the folder where you have unpacked the DOTT docu and examples zip archive. Build the examples and the DOTT library by calling <em>make</em>.</p>
<h1><a class="anchor" id="Dev_ConfTest"></a>
DOTT Configuration Reference</h1>
<p>DOTT uses two locations for configuration. First, in a folder containing tests there usually is a <em>dott.ini</em> file which is described here. The content of the <em>dott.ini</em> is parsed on startup and stored in an internal data structure called <em>DottConf</em>. The names of the configuration options stored in the <em>DottConf</em> structure match those from the <a class="el" href="DeveloperGuide.html#Dev_DottIni">dott.ini</a>. If no <em>dott.ini</em> file can be found, the <em>DottConf</em> is filled with default values.</p>
<p>In <em>conftest.py</em> (PyTest configuration) which usually is also located in the test folder or a parent folder, the content of the <em>DottConf</em> structure can be altered programmatically. Here you can override settings in DottConf or set options based on the host name the tests are executed on. This is quite handy to have one configuration file with different config options depending on if the file is executed on the developer PC or a Jenkins slave. The example and template projects coming with DOTT include <em>conftest.py</em> files for your reference. <br />
 </p>
<h2><a class="anchor" id="Dev_DottIni"></a>
DOTT Ini / DottConf  Settings</h2>
<ul>
<li><b>app_load_elf</b> shall point to the location of the ELF-wrapped app binary as downloaded to the target</li>
<li><b>app_symbol_elf</b> shall point to the app ELF file which contains all the debug information</li>
<li><b>bl_load_elf</b> shall point to the location of the ELF-wrapped bootloader binary (if any) as downloaded to the target</li>
<li><b>bl_symbol_addr</b> address for the bootloader symbol file in hex (with 0x prefix)</li>
<li><b>bl_symbol_elf</b> shall point to the bootloader ELF file (if any) which contains all the debug information</li>
<li><b>device_endianess</b> endianess of the target device. 'little' (default) or 'big'</li>
<li><b>device_name</b> shall be the device name as specified in <em>JLinkDevices.xml</em></li>
<li><b>gdb_client_binary</b> GDB client binary. if omitted the default one coming with the DOTT runtime is used</li>
<li><b>gdb_server_addr</b> shall be the IP address where the J-Link GDB server is running. Omit if you want DOTT to auto-start the GDB server locally.</li>
<li><b>gdb_server_binary</b> server binary coming with a J-Link installation. auto-detected if omitted.</li>
<li><b>gdb_server_port</b> port when connecting to a remote GDB server. Using default (2331) if omitted.</li>
<li><b>jlink_interface</b> interface between debug probe and target. SWD (default) or JTAG</li>
<li><b>jlink_serial</b> serial number of the J-Link to use. useful if more than one J-Link is connected</li>
<li><b>jlink_speed</b> interface speed for the J-Link debug probe (consult Segger manual for more information)</li>
<li><b>jlink_server_addr</b> shall be the IP address where the J-Link server is running. Omit if you want DOTT to auto-start the JLINK server locally.</li>
<li><b>jlink_server_port</b> port when connecting to a remote JLINK server. Using default (19020) if omitted. </li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>

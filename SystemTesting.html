<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Debugger-based On-Target Testing: System Testing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ams_dott_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Debugger-based On-Target Testing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">System Testing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#GetStarted_FreeRunningTests">System (Free-Running) Test Examples</a><ul><li class="level2"><a href="#ExampleSystemTestExecution">Executing Example Component Tests</a></li>
<li class="level2"><a href="#GS_UnderstandingSysTestExamples">Understanding the Example System Tests</a><ul><li class="level3"><a href="#GS_SysInitTests">System Initialization Tests</a></li>
<li class="level3"><a href="#GS_SysTickTests">Systick Tests and Live Access</a></li>
<li class="level3"><a href="#GS_CommandTests">Command Processor Tests</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>System testing with DOTT is also referred to as 'free running mode' testing. This essentially means DOTT is used to download the firmware to the target and boot it up and let the firmware run while providing external stimuli via the target's external communication interfaces.</p>
<p>To execute the included system test examples please use the reference target platform describe in setup section.</p>
<h1><a class="anchor" id="GetStarted_FreeRunningTests"></a>
System (Free-Running) Test Examples</h1>
<p>When implementing system tests, DOTT is used in <em>free running mode</em> where the target is running while external stimuli are provided and, at predefine points in time, the target's internal state is inspected using DOTT.</p>
<p>One way how to provide external stimuli to the external interfaces of a target is described in the section <a class="el" href="ExternalEquipment.html">External Test Equipment</a>. A simple system testing example which uses this approach together with the <a class="el" href="ReferencePlatform.html">Reference Board</a> is included in dott. The I2C connection between the reference board and the Raspberry Pi has to be established follows:</p>
<div class="fragment"><div class="line">|---------------|      SDA (GPIO2)        SDA (D14)    |-----------|</div><div class="line">| RASPBERRY PI  |   &lt;------------------------------&gt;   | STM32F072 |</div><div class="line">|               |                                      |           |</div><div class="line">|               |      SCL (GPIO3)        SCL (D15)    |           |</div><div class="line">|               |   -------------------------------&gt;   |           |</div><div class="line">| pigpio daemon |                                      |           |</div><div class="line">|               |   GND                         GND    |           |</div><div class="line">|---------------|   --------------------------------   |-----------|</div></div><!-- fragment --><p>Before executing the tests you need to edit the <em>conftest.py</em> file locate in the examples folder. In the function add an <em>elif</em> branch for your host machine as shown below. Replace <b>YOUR_HOST_NAME</b> with the host name of your machine where you run pytest and replace <b>AAA.BBB.CCC.DDD</b> with the IP address of your RaspberryPi where PiGPIOD is running.</p>
<div class="fragment"><div class="line"><span class="keyword">def </span>set_config_options():</div><div class="line">    <span class="comment"># machine-specific settings (selected based on hostname)</span></div><div class="line"></div><div class="line">    <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> hostname == <span class="stringliteral">&#39;V1852354E&#39;</span>:</div><div class="line">        <span class="comment"># ...</span></div><div class="line"></div><div class="line">    <span class="keywordflow">elif</span> hostname == <span class="stringliteral">&#39;YOUR_HOST_NAME&#39;</span>:</div><div class="line">        DottConf.set(<span class="stringliteral">&#39;pigpio_addr&#39;</span>, <span class="stringliteral">&#39;AAA.BBB.CCC.DDD&#39;</span>)  <span class="comment"># remote PiGPIO daemon on your RaspberryPI</span></div></div><!-- fragment --><h2><a class="anchor" id="ExampleSystemTestExecution"></a>
Executing Example Component Tests</h2>
<p>Once the I2C hardware connection is established between target and RaspberryPi and and the GPIO daemon on the RaspberryPi is set up and running, the tests can be executed. To do so, open a Python command prompt (and activate the DOTT venv if using a virtual environment). In the command prompt now navigate to the <code>examples\02_system_testing</code> of the dott examples package downloaded from GitHub:</p>
<div class="fragment"><div class="line">&gt; cd dott_doc_examples_xxx\examples\02_system_testing\host</div><div class="line">&gt; dir</div><div class="line">02.01.2019  08:22             2.008 dott.ini</div><div class="line">02.01.2019  08:22             4.916 test_i2c_comm.py</div><div class="line">02.01.2019  08:22             4.933 test_sysinit.py</div></div><!-- fragment --><p>Now you can no run the tests by calling <b>pytest</b>:</p>
<div class="image">
<img src="dott_example_sys_tests.png" alt="dott_example_sys_tests.png"/>
<div class="caption">
Example system tests using I2C as external target interface.</div></div>
 <h2><a class="anchor" id="GS_UnderstandingSysTestExamples"></a>
Understanding the Example System Tests</h2>
<p>The target firmware for the example system tests are based on code generated with the STM Cube MX tool. The code base in the <em>target</em> folder includes the STM32 HAL library, CMSIS support code and peripheral initialization code. The actual code under test are located in <em>Src/example.c</em> and implements a simple command processor which receives commands from the host via I2C. The following table summarizes the core components of the example:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Content  </th><th class="markdownTableHeadNone">Source File   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Timer functions <b>on target</b>  </td><td class="markdownTableBodyNone"><em>examples/02_system_testing/target/Src/examples_cntr.c</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Command functions <b>on target</b>  </td><td class="markdownTableBodyNone"><em>examples/02_system_testing/target/Src/examples_cmd.c</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">counter tests <b>on host</b>  </td><td class="markdownTableBodyNone"><em>examples/02_system_testing/host/test_cntr.py</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">system init tests <b>on host</b>  </td><td class="markdownTableBodyNone"><em>examples/02_system_testing/host/test_sysinit.py</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">I2C command communication tests <b>on host</b>  </td><td class="markdownTableBodyNone"><em>examples/02_system_testing/host/test_i2c_comm.py</em>   </td></tr>
</table>
<h3><a class="anchor" id="GS_SysInitTests"></a>
System Initialization Tests</h3>
<p>The following test is an example how DOTT can be used to test basic system initialization functionality. In the target firmware, there is a variable called *_sample_cnt* located in the BSS (meaning that the variable shall be zero-initialized by the compiler's runtime). It is a good practice to randomly check that zero initialization is performed as expected. The following test halts the target in the reset handler (i.e., before the compiler's runtime gets control), writes a well known pattern into the variable in BSS section and then continues target execution. The target is halted again when reaching <em>main</em>. There it is checked that the variable was initialized to zero by the startup code of the compiler's runtime.</p>
<div class="fragment"><div class="line"><span class="comment"># code snippet from  test_sysinit.py</span></div><div class="line"></div><div class="line"><span class="keyword">def </span>test_sysinit_bss_section(self, target_load, target_reset):</div><div class="line">    <span class="comment"># when entering the test the target is halted at the DOTT test hook</span></div><div class="line"></div><div class="line">    <span class="comment"># create halt points in Reset_Handler and main</span></div><div class="line">    hp_reset = HaltPoint(<span class="stringliteral">&#39;Reset_Handler&#39;</span>)</div><div class="line">    hp_main = HaltPoint(<span class="stringliteral">&#39;main&#39;</span>)</div><div class="line"></div><div class="line">    <span class="comment"># reset the target, let it run and wait until it has reached the reset handler</span></div><div class="line">    dott().target.reset()</div><div class="line">    dott().target.cont()</div><div class="line">    hp_reset.wait_complete()</div><div class="line"></div><div class="line">    <span class="comment"># write some well known, non-zero pattern int a variable located in the BSS section</span></div><div class="line">    pattern = 0xaabbaabb</div><div class="line">    dott().target.eval(f<span class="stringliteral">&#39;_sample_cnt = {pattern}&#39;</span>)</div><div class="line">    <span class="keyword">assert</span> (pattern == dott().target.eval(<span class="stringliteral">&#39;_sample_cnt&#39;</span>)), <span class="stringliteral">&#39;expected to read back test pattern&#39;</span></div><div class="line"></div><div class="line">    <span class="comment"># continue and wait until main has been reached; the variable in bss shall now be zero</span></div><div class="line">    dott().target.cont()</div><div class="line">    hp_main.wait_complete()</div><div class="line">    <span class="keyword">assert</span> (0x0 == dott().target.eval(<span class="stringliteral">&#39;_sample_cnt&#39;</span>)), <span class="stringliteral">&#39;expected to read back zero&#39;</span></div></div><!-- fragment --><p>A similar test called <em>test_sysinit_data_section</em> can also be in <em>test_sysinit.py</em>. This one checks that a variable located in the data section is properly initialized by the compiler's runtime (i.e., the initial content of the variable was correctly copied form FLASH memory to RAM).</p>
<h3><a class="anchor" id="GS_SysTickTests"></a>
Systick Tests and Live Access</h3>
<p>A standard feature of Cortex-M MCU frequently used together with an RTOS is the Systick timer. With DOTT it is easy to (roughly) check if the systick counter was configured correctly and is advancing as expected. The following test shows how to do that:</p>
<div class="fragment"><div class="line"><span class="comment"># the following code is from file test_cntr.py</span></div><div class="line"></div><div class="line"><span class="keyword">def </span>test_SystickRunning(self, target_load, target_reset):</div><div class="line">    <span class="keyword">assert</span> (0 == dott().target.eval(<span class="stringliteral">&#39;_tick_cnt&#39;</span>)), <span class="stringliteral">&#39;Systick count shall initially be zero.&#39;</span></div><div class="line">    dott().target.cont()</div><div class="line">    time.sleep(2)</div><div class="line">    dott().target.halt()</div><div class="line">    <span class="keyword">assert</span> (2000 &lt;= dott().target.eval(<span class="stringliteral">&#39;_tick_cnt&#39;</span>)), <span class="stringliteral">&#39;Systick counter should have advanced while target was running&#39;</span></div></div><!-- fragment --><p>An alternative implementation shown next uses DOTT's <em>live access</em> feature which allows to read and write target memory <em>while</em> the target is running. Live access is a special pytest fixture provided by DOTT and hence tests using live_access need to include it in the test's signature.</p>
<div class="fragment"><div class="line"><span class="comment"># code snippet from test_cntr.py</span></div><div class="line"></div><div class="line"><span class="keyword">def </span>test_SystickRunningLive(self, target_load, target_reset, live_access):</div><div class="line">    cnt_addr = dott().target.eval(<span class="stringliteral">&#39;&amp;_tick_cnt&#39;</span>)</div><div class="line">    cnt_last = dott().target.eval(<span class="stringliteral">&#39;_tick_cnt&#39;</span>)</div><div class="line">    <span class="keyword">assert</span> (0 == cnt_last), <span class="stringliteral">&#39;Systick count shall initially be zero.&#39;</span></div><div class="line">    dott().target.cont()</div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> i <span class="keywordflow">in</span> range(10):</div><div class="line">        time.sleep(.2)</div><div class="line">        cnt = live_access.mem_read_32(cnt_addr)</div><div class="line">        <span class="keyword">assert</span> (cnt &gt; cnt_last), <span class="stringliteral">&#39;Systick counter should have advanced&#39;</span></div><div class="line">        cnt_last = cnt</div></div><!-- fragment --><h3><a class="anchor" id="GS_CommandTests"></a>
Command Processor Tests</h3>
<p>The examples also include a simple on-target command processor component which receives command packets (consisting of an 8bit command ID and two 32bit arguments) from the host. The command packets are parsed and the respective command handler functions are then called. The following code shows the target implementation of the command processor. The reading of the command data on from the I2C peripheral is performed using DMA and and interrupt is generated when the next command packet was received. The processing of the command data is performed in the <em>app_main</em> loop. If a command, such as <em>ADD</em>, was recognized, the corresponding command handler is called.</p>
<div class="fragment"><div class="line"><span class="comment">// for full code see example_cmd.c</span></div><div class="line"></div><div class="line"><span class="comment">// size of a command packet read via I2C</span></div><div class="line"><span class="preprocessor">#define CMD_PKT_SZ 9</span></div><div class="line"></div><div class="line"><span class="comment">// command packet IDs</span></div><div class="line"><span class="preprocessor">#define CMD_ID_ADD 0x10</span></div><div class="line"></div><div class="line"><span class="comment">// flag which indicates that new command data is available in _data</span></div><div class="line"><span class="keyword">static</span> <span class="keywordtype">bool</span> _data_ready = <span class="keyword">false</span>;</div><div class="line"><span class="comment">// buffer holding new command data</span></div><div class="line"><span class="keyword">static</span> uint8_t _data[128] = {0, };</div><div class="line"><span class="comment">// buffer used by the DMA controller to store incoming I2C data</span></div><div class="line"><span class="keyword">static</span> uint8_t _recv_buf[128] = {0, };</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Struct used to hold a command ID plus command handler (function pointer).</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>command {</div><div class="line">    uint8_t id;</div><div class="line">    void (*func)(uint8_t*);</div><div class="line">} command_t;</div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Command handler which computes the sum of two operands received via I2C.</span></div><div class="line"><span class="comment"> * The sum is not used any further but only inspected for correctness via a</span></div><div class="line"><span class="comment"> * host-side test.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> cmd_add(uint8_t *payload)</div><div class="line">{</div><div class="line">    <span class="keyword">static</span> uint32_t a, b, sum;</div><div class="line">    a = payload[0] | payload[1] &lt;&lt; 8 | payload[2] &lt;&lt; 16 | payload[3] &lt;&lt; 24;</div><div class="line">    b = payload[4] | payload[5] &lt;&lt; 8 | payload[6] &lt;&lt; 16 | payload[7] &lt;&lt; 24;</div><div class="line">    sum = a + b;</div><div class="line"></div><div class="line">    DOTT_LABEL(<span class="stringliteral">&quot;CMD_ADD_EXIT&quot;</span>);</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * List of command IDs and corresponding command handlers (function pointers).</span></div><div class="line"><span class="comment"> */</span></div><div class="line">command_t commands[] = {</div><div class="line">        {CMD_ID_ADD, &amp;cmd_add},</div><div class="line">        <span class="comment">/* ... */</span></div><div class="line">        {0, NULL} <span class="comment">// termination element; note: 0 is not a valid command id</span></div><div class="line">};</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Application main loop which reads command packages from the I2C bus, looks</span></div><div class="line"><span class="comment"> * up the correct command handler and then calls the handler function.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> app_main()</div><div class="line">{</div><div class="line">    <span class="comment">// initial, non-blocking call to I2C receive function</span></div><div class="line">    HAL_I2C_Slave_Receive_DMA(&amp;hi2c1, _recv_buf, CMD_PKT_SZ);</div><div class="line"></div><div class="line">    <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div><div class="line"></div><div class="line">        <span class="keywordflow">if</span> (_data_ready) {</div><div class="line">            uint8_t cmd_id = _data[0];</div><div class="line">            uint16_t i = 0;</div><div class="line">            void (*func)(uint8_t*) = NULL;</div><div class="line"></div><div class="line">            <span class="keywordflow">while</span>(<span class="keyword">true</span>) {</div><div class="line">                <span class="keywordflow">if</span> (commands[i].<span class="keywordtype">id</span> == 0) {</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                <span class="keywordflow">if</span> (commands[i].<span class="keywordtype">id</span> == cmd_id) {</div><div class="line">                    func = commands[i].func;</div><div class="line">                    <span class="keywordflow">break</span>;</div><div class="line">                }</div><div class="line"></div><div class="line">                i++;</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// non-blocking call to I2C receive function</span></div><div class="line">            HAL_I2C_Slave_Receive_DMA(&amp;hi2c1, _recv_buf, CMD_PKT_SZ);</div><div class="line">            _data_ready = <span class="keyword">false</span>;</div><div class="line"></div><div class="line">            DOTT_LABEL(<span class="stringliteral">&quot;I2C_READ_DONE&quot;</span>);</div><div class="line"></div><div class="line">            <span class="keywordflow">if</span> (func != NULL) {</div><div class="line">                func(_data + 1);</div><div class="line">            } <span class="keywordflow">else</span> {</div><div class="line">                DOTT_LABEL(<span class="stringliteral">&quot;UNKNOWN_CMD&quot;</span>);</div><div class="line">                <span class="comment">// add whatever code is needed to handle unknwon commands; e.g., </span></div><div class="line">                <span class="comment">// send an error message to the host etc.; omitted from the example</span></div><div class="line">                __NOP();</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment"> * Callback called from STM32 HAL when an I2C DMA transfer is complete.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> __attribute__((noinline)) HAL_I2C_SlaveRxCpltCallback(I2C_HandleTypeDef *hi2c)</div><div class="line">{</div><div class="line">    memcpy(_data, _recv_buf, 128);</div><div class="line">    _data_ready = <span class="keyword">true</span>;</div><div class="line">}  </div></div><!-- fragment --><p>The following test now starts the target and sends a command packet via I2C. It then halts the target using a <em>HaltPoint</em> when reaching a label called <em>CMD_ADD_EXIT</em> which is located at the end of the <em>cmd_add</em> function from the target code snipped above. The test then checks if the two operands <em>a</em> and <em>b</em> were correctly de-serialized and if the sum computed on the target matches the expected one.</p>
<div class="fragment"><div class="line"><span class="comment"># code snippet from test_i2c_comm.py</span></div><div class="line"></div><div class="line"><span class="keyword">def </span>test_CmdAdd(self, target_load, target_reset, i2c_comm):</div><div class="line">    hp = HaltPoint(DOTT_LABEL(<span class="stringliteral">&#39;CMD_ADD_EXIT&#39;</span>))</div><div class="line"></div><div class="line">    a = 78231231</div><div class="line">    b = 12345678</div><div class="line">    a_bytes = DottConvert.uint32_to_bytes(a)</div><div class="line">    b_bytes = DottConvert.uint32_to_bytes(b)</div><div class="line"></div><div class="line">    dott().target.cont()</div><div class="line">    i2c_comm.pi.i2c_write_device(i2c_comm.dev, [0x10, *a_bytes, *b_bytes])</div><div class="line"></div><div class="line">    hp.wait_complete(timeout=4)</div><div class="line">    deser_a = dott().target.eval(<span class="stringliteral">&#39;a&#39;</span>)</div><div class="line">    deser_b = dott().target.eval(<span class="stringliteral">&#39;b&#39;</span>)</div><div class="line">    <span class="keyword">assert</span> (a == deser_a), <span class="stringliteral">&#39;deserialized data on target does not match sent data&#39;</span></div><div class="line">    <span class="keyword">assert</span> (b == deser_b), <span class="stringliteral">&#39;deserialized data on target does not match sent data&#39;</span></div><div class="line"></div><div class="line">    sum = dott().target.eval(<span class="stringliteral">&#39;sum&#39;</span>)</div><div class="line">    <span class="keyword">assert</span> ((a + b) == sum), <span class="stringliteral">&#39;sum does not match expected value&#39;</span></div></div><!-- fragment --><p>You might also want to check how the target firmware behaves if, e.g., due to a transmission error the command ID has become invalid. The following example shows how such faults are injected into the execution flow. This is achieved using and <em>InterceptPoint</em> placed in the <em>HAL_I2C_SlaveRxCpltCallback</em> (the callback function invoked by the STM32 HAL when the next I2C command packet was received using DMA transfer). In the InterceptPoint's <em>reached</em> method the command ID byte is modified to an illegal value (0xff). The test then expects the target to hit the <em>UNKNOWN_CMD</em> label in the target's firmware. If this label is not hit, the test will fail.</p>
<div class="fragment"><div class="line"><span class="comment"># code snippet from test_i2c_comm.py</span></div><div class="line"></div><div class="line"><span class="keyword">def </span>test_CmdInjectUnknown(self, target_load, target_reset, i2c_comm):</div><div class="line">    hp = HaltPoint(DOTT_LABEL(<span class="stringliteral">&#39;UNKNOWN_CMD&#39;</span>))</div><div class="line"></div><div class="line">    <span class="keyword">class </span>MyIp(InterceptPoint):</div><div class="line">        <span class="keyword">def </span>reached(self):</div><div class="line">            self.eval(<span class="stringliteral">&#39;_recv_buf[0] = 0xff&#39;</span>)</div><div class="line"></div><div class="line">    ip = MyIp(<span class="stringliteral">&#39;HAL_I2C_SlaveRxCpltCallback&#39;</span>)</div><div class="line"></div><div class="line">    a = 78231231</div><div class="line">    b = 12345678</div><div class="line">    a_bytes = DottConvert.uint32_to_bytes(a)</div><div class="line">    b_bytes = DottConvert.uint32_to_bytes(b)</div><div class="line"></div><div class="line">    dott().target.cont()</div><div class="line">    i2c_comm.pi.i2c_write_device(i2c_comm.dev, [0x10, *a_bytes, *b_bytes])</div><div class="line"></div><div class="line">    <span class="keywordflow">try</span>:</div><div class="line">        hp.wait_complete(timeout=4)</div><div class="line">    <span class="keywordflow">except</span> TimeoutError:</div><div class="line">        <span class="keyword">assert</span> <span class="keyword">False</span>, <span class="stringliteral">&#39;Command not detected as unknown command.&#39;</span></div></div><!-- fragment --> </div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>

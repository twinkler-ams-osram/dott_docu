<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.14"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Debugger-based On-Target Testing: Component Testing</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="doxyStyle.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ams_dott_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Debugger-based On-Target Testing
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.14 -->
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',false,false,'search.php','Search');
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Component Testing </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ComponentTests">Component (Halt Mode) Test Examples</a><ul><li class="level2"><a href="#ExampleComponentTestExecution">Executing Example Component Tests</a></li>
<li class="level2"><a href="#GS_UnderstandingExamples">Understanding the Example Component Tests</a><ul><li class="level3"><a href="#ExampleSimple">Simple Function Calls</a></li>
<li class="level3"><a href="#ExamplePointers">Functions with Pointer and Struct Arguments</a></li>
<li class="level3"><a href="#ExampleArrays">Strings and Array Arguments</a></li>
<li class="level3"><a href="#ExampleFuncPointers">Function Pointer Arguments</a></li>
<li class="level3"><a href="#ExampleInjection">Data Injection in Sub-calls</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>Component testing with DOTT is also referred to as 'halt mode' testing. This essentially means DOTT is used to download the firmware to the target and boot it up and then halt it in a defined location called the DOTT test hook. From there, functions implemented in the firmware can be called in a component/unit testing style.</p>
<p>To execute the included component test examples please use the reference target platform describe in setup section.</p>
<h1><a class="anchor" id="ComponentTests"></a>
Component (Halt Mode) Test Examples</h1>
<p>This section shows how to run component (unit) test examples where software functions implemented in the target's firmware are called from tests implemented on the host (cp. <a class="el" href="index.html#Architecture">DOTT architecture</a>).</p>
<h2><a class="anchor" id="ExampleComponentTestExecution"></a>
Executing Example Component Tests</h2>
<p>First, open a Python command prompt (and activate the DOTT venv if using a virtual environment). In the command prompt now navigate to the <code>dott_doc_examples_xxx\examples\01_component_testing</code> of the dott examples package downloaded from GitHub:</p>
<div class="fragment"><div class="line">&gt; cd dott_doc_examples_xxx\examples\01_component_testing</div><div class="line">&gt; dir</div><div class="line">29.11.2018  14:19    &lt;DIR&gt;          host</div><div class="line">29.11.2018  14:19    &lt;DIR&gt;          target</div></div><!-- fragment --><p>As you can see in the snippet above, the folder contains host and a target folders. The <b>target</b> folder contains the firmware under test which is downloaded to the target device as part of test execution. The target folder contains both the source code as well as pre-compiled firmware binaries. The <b>host</b> folder contains the actual tests implemented in Python. Now lets change into the host folder and invoke <b>pytest</b> to start the test execution:</p>
<div class="fragment"><div class="line">&gt; cd host</div><div class="line">&gt; pytest</div></div><!-- fragment --><p>Upon first execution you will be prompted with the following license information dialog from the Segger J-Link debug probe. Please make sure to tick the checkbox on the bottom left (highlighted in green) and then click accept (highlighted in green). Please note that you will get this message only when using the reference board with an ST-Link converted to a J-Link. If you are using a standalone J-Link debug probe you will not get this message.</p>
<div class="image">
<img src="segger_license.png" alt="segger_license.png"/>
<div class="caption">
Segger J-Link / ST-Link license dialog.</div></div>
<p> As a result, you should see an output similar to this:</p>
<div class="image">
<img src="dott_example_tests.png" alt="dott_example_tests.png"/>
<div class="caption">
Example tests for functions implemented in the firmware of the reference board.</div></div>
 <h2><a class="anchor" id="GS_UnderstandingExamples"></a>
Understanding the Example Component Tests</h2>
<p>The following sections show selected functions implemented in the firmware under test (executed on the reference board) and the corresponding tests implemented in Python on the host. The source files for the example functions under test and corresponding host-side tests are given in the table below. Note that not all examples in the source files are discussed here.</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Content  </th><th class="markdownTableHeadNone">Source File   </th></tr>
<tr class="markdownTableBody" class="markdownTableRowOdd">
<td class="markdownTableBodyNone">Firmware functions <b>on target</b>  </td><td class="markdownTableBodyNone"><em>examples/01_component_testing/target/testexamples.c</em>   </td></tr>
<tr class="markdownTableBody" class="markdownTableRowEven">
<td class="markdownTableBodyNone">Corresponding <b>host-side</b> tests  </td><td class="markdownTableBodyNone"><em>examples/01_component_testing/host/test_example_functions.py</em>   </td></tr>
</table>
<h3><a class="anchor" id="ExampleSimple"></a>
Simple Function Calls</h3>
<p>The following examples show how target functions are called by their symbol name from the host and how scalar parameters and return values are handled. Note that it is also no problem to call <b>static functions</b>.</p>
<ul>
<li><p class="startli"><b>Target functions</b></p>
<p class="startli">The following functions take either no argument or take scalars as arguments and return scalar results. </p><div class="fragment"><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function without any arguments.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">uint32_t __attribute__((used)) example_NoArgs(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> 42;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Static function without any arguments.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> uint32_t __attribute__((used)) example_NoArgsStatic(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="keyword">volatile</span> uint32_t val = 42;</div><div class="line">    <span class="keywordflow">return</span> val;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function with simple scalar arguments.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">uint32_t __attribute__((used)) example_Addition(uint32_t a, uint32_t b)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> a + b;</div><div class="line">}</div></div><!-- fragment --></li>
<li><p class="startli"><b>Host-side tests</b></p>
<p class="startli">On the host, the target functions are called in PyTest test cases shown below. Note that the tests take <b>test fixtures</b> as arguments. DOTT offers pre-defined test fixtures for re-occurring tasks such as downloading the firmware onto the target or resetting the target. Note that for most tests it is important to bring the target into a <b>defined, well known state</b> before starting with the test execution. Details on DOTT test fixtures can be found in the Developer's Guide. </p><div class="fragment"><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_NoArgs(self, target_load, target_reset):</div><div class="line">    res = dott().target.eval(<span class="stringliteral">&#39;example_NoArgs()&#39;</span>)</div><div class="line">    assert(42 == res)</div><div class="line"></div><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_NoArgsStatic(self, target_load, target_reset):</div><div class="line">    res = dott().target.eval(<span class="stringliteral">&#39;example_NoArgsStatic()&#39;</span>)</div><div class="line">    assert(42 == res)</div><div class="line"></div><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_Addition(self, target_load, target_reset):</div><div class="line">    res = dott().target.eval(<span class="stringliteral">&#39;example_Addition(31, 11)&#39;</span>)</div><div class="line">    assert(42 == res)</div></div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="ExamplePointers"></a>
Functions with Pointer and Struct Arguments</h3>
<p>The following examples illustrate how to call target functions which take or return pointers or structs. In contrast to simple scalars, memory on the target must be allocated which is then loaded with the intended values. Note that this does not imply the existence of a heap on the target but a DOTT-specific mechanism is used for memory allocation. Details on that are provided in the <a class="el" href="DeveloperGuide.html#Dev_CallingTargetFunctions">Developer's Guide</a>.</p>
<ul>
<li><p class="startli"><b>Target functions with pointer arguments</b></p>
<p class="startli">A target function example taking three pointers, one used for the result of the addition and two for the operands. </p><div class="fragment"><div class="line">/**</div><div class="line"> * Function with pointer arguments <span class="keywordflow">and</span> pointer-based <span class="keywordflow">return</span> value.</div><div class="line"> */</div><div class="line">uint32_t __attribute__((used)) example_AdditionPtrRet(uint32_t *const a, uint32_t *const b, uint32_t *sum)</div><div class="line">{</div><div class="line">    *sum = *a + *b;</div><div class="line">    <span class="keywordflow">return</span> *sum;</div><div class="line">}</div></div><!-- fragment --></li>
<li><p class="startli"><b>Host-side tests with pointer arguments</b></p>
<p class="startli">First, memory has to be allocated on the target. For memory allocation and initialization a DOTT function called <em>mem.alloc_type</em> is used. Note that this function does not require dynamic memory (heap) in the target. Details on on-target memory allocation are provided in the <a class="el" href="DeveloperGuide.html#Dev_CallingTargetFunctions">Developer's Guide</a>. <br />
The allocated memory can be accessed either via <em>GDB convenience variables</em> (starting with a $ prefix) or via their addresses as returned by <em>mem.alloc_type</em>. The names of the <em>GDB convenience variables</em> can be set as optional arguments when calling <em>mem.alloc_type</em>.</p>
<p class="startli">The following two, functionally identical, tests show how to call a target function taking pointer arguments. The first variant uses <em>GDB convenience variables</em> while the second one directly uses the memory addresses returned by <em>mem.alloc_type</em> in Python f-Strings. </p><div class="fragment"><div class="line"><span class="comment">## variant relying on &quot;GDB convenience variables&quot; </span></div><div class="line"><span class="keyword">def </span>test_example_AdditionPtrRet(self, target_load, target_reset):</div><div class="line">    dott().target.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, val=10, var_name=<span class="stringliteral">&#39;$a&#39;</span>) <span class="comment"># allocate target memory for an uint32_t</span></div><div class="line">    dott().target.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, val=999, var_name=<span class="stringliteral">&#39;$b&#39;</span>)</div><div class="line">    dott().target.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, val=0, var_name=<span class="stringliteral">&#39;$sum&#39;</span>)</div><div class="line">    res = dott().target.eval(<span class="stringliteral">&#39;example_AdditionPtrRet($a, $b, $sum)&#39;</span>)</div><div class="line">    my_sum = dott().target.eval(<span class="stringliteral">&#39;*$sum&#39;</span>)</div><div class="line">    assert(1009 == res), <span class="stringliteral">&#39;Unexpected return value&#39;</span></div><div class="line">    assert(1009 == my_sum), <span class="stringliteral">&#39;Unexpected return value&#39;</span></div><div class="line"></div><div class="line"><span class="comment">## alternate variant without using &quot;GDB convenience variables&quot;</span></div><div class="line"><span class="keyword">def </span>test_example_AdditionPtrRet_Alternate(self, target_load, target_reset):</div><div class="line">    dt = dott().target</div><div class="line">    p_a = dt.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, val=10)</div><div class="line">    p_b = dt.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, val=999)</div><div class="line">    p_sum = dt.mem.alloc_type(<span class="stringliteral">&#39;uint32_t&#39;</span>, val=0)</div><div class="line">    res = dt.eval(f<span class="stringliteral">&#39;example_AdditionPtrRet({p_a}, {p_b}, {p_sum})&#39;</span>)</div><div class="line">    my_sum = dt.eval(f<span class="stringliteral">&#39;*{p_sum}&#39;</span>)</div><div class="line">    assert(1009 == res), <span class="stringliteral">&#39;Unexpected return value&#39;</span></div><div class="line">    assert(1009 == my_sum), <span class="stringliteral">&#39;Unexpected return value&#39;</span></div></div><!-- fragment --></li>
<li><p class="startli"><b>Target functions with struct arguments</b></p>
<p class="startli">This on-target function takes a struct as argument and performs an addition of two of the struct elements and saves the result in another struct element. </p><div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line">    uint32_t a;</div><div class="line">    uint8_t  paddB; <span class="comment">// non-word size padding for testing purposes</span></div><div class="line">    uint32_t b;</div><div class="line">    uint32_t sum;</div><div class="line">} my_add_t;</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function with struct as argument.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">uint32_t __attribute__((used)) example_AdditionStruct(my_add_t ms)</div><div class="line">{</div><div class="line">    ms.sum = ms.a + ms.b;</div><div class="line">    <span class="keywordflow">return</span> ms.sum;</div><div class="line">}</div></div><!-- fragment --></li>
<li><p class="startli"><b>Host-side tests with struct arguments</b></p>
<p class="startli">In the host-side test, again on-traget memory is allocated for the struct and the address is stored in <em>$add_data</em>. The struct elements are then filled and the The de-referenced struct pointer is then passed as argument to the target function <em>example_AdditionStruct</em>. </p><div class="fragment"><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_AdditionStruct_Alternate(self, target_load, target_reset):</div><div class="line">    dt = dott().target</div><div class="line">    p_dat = dt.mem.alloc_type(<span class="stringliteral">&#39;my_add_t&#39;</span>)</div><div class="line">    dt.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;a = 55&#39;</span>)</div><div class="line">    dt.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;b = 22&#39;</span>)</div><div class="line">    dt.eval(f<span class="stringliteral">&#39;{p_dat}-&gt;sum = 0&#39;</span>)</div><div class="line">    res = dt.eval(f<span class="stringliteral">&#39;example_AdditionStruct(*{p_dat})&#39;</span>)</div><div class="line">    assert(77 == res), <span class="stringliteral">&#39;Unexpected return value&#39;</span></div></div><!-- fragment --><p class="startli">Note that filling the (on-target) struct elements with desired values is a relatively slow process since every value setting operation translates to a single debugger memory access via GDB. To enhance performances, target memory can be also accessed in bulk operations which leads to a performance improvement. Details on this can be found in the <a class="el" href="DeveloperGuide.html#Dev_MemoryPerformance">Developer Guide</a>.</p>
</li>
</ul>
<h3><a class="anchor" id="ExampleArrays"></a>
Strings and Array Arguments</h3>
<p>With DOTT is is also possible to pass strings and other array data to target functions which is illustrated in this example.</p>
<ul>
<li><p class="startli"><b>Target functions</b></p>
<p class="startli">The first example implements a function returning the length of a string. The second example takes an array of integers and returns the sum of the elements. </p><div class="fragment"><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function taking a string argument and returning the string&#39;s length.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t __attribute__((used)) example_StringLen(<span class="keywordtype">char</span> *msg)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> strlen(msg);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function which returns the sum of the elements in the provided array.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> int32_t __attribute__((used)) example_SumElements(uint16_t *elem, uint16_t elem_sz)</div><div class="line">{</div><div class="line">    int32_t ret_val = 0;</div><div class="line">    <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; elem_sz; i++) {</div><div class="line">        ret_val += elem[i];</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> ret_val;</div><div class="line">}</div></div><!-- fragment --></li>
<li><p class="startli"><b>Host-side tests</b></p>
<p class="startli">On the host, for both tests first memory has to be allocated on the target to hold the string/ array content. Next, the array on target has to be filled with content using the <em>mem.write</em> function provided by DOTT. As a convenience feature, initial initialization can also be performed when calling <em>mem.alloc_type</em>. Note that the second examples uses Python's ctypes module to convert the Python integer array into an array of uint16_t types. Thereafter, the example functions on the target can be called and the results can be checked against the expected ones. </p><div class="fragment"><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_ArgString(self, target_load, target_reset):</div><div class="line">    msg = <span class="stringliteral">&#39;Sensing is life.\0&#39;</span></div><div class="line"></div><div class="line">    addr = dott().target.mem.alloc_type(<span class="stringliteral">&#39;char&#39;</span>, cnt=len(msg), val=0x0)</div><div class="line">    dott().target.mem.write(addr, msg.encode(encoding=<span class="stringliteral">&#39;ascii&#39;</span>))</div><div class="line">    res = dott().target.eval(f<span class="stringliteral">&#39;example_StringLen({addr})&#39;</span>)</div><div class="line">    assert(len(msg) - 1 == res), f<span class="stringliteral">&#39;expected: {len(msg)}, is: {res}&#39;</span></div><div class="line"></div><div class="line">    <span class="comment"># same as above but with direct setting of initial data (skipping mem.write)</span></div><div class="line">    addr = dott().target.mem.alloc_type(<span class="stringliteral">&#39;char&#39;</span>, cnt=len(msg), val=msg)</div><div class="line">    res = dott().target.eval(f<span class="stringliteral">&#39;example_StringLen({addr})&#39;</span>)</div><div class="line">    assert(len(msg) - 1 == res), f<span class="stringliteral">&#39;expected: {len(msg)}, is: {res}&#39;</span></div><div class="line"></div><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_SumElements(self, target_load, target_reset):</div><div class="line">    elements = [0, 1, 2, 65535, 99]</div><div class="line">    addr = dott().target.mem.alloc_type(<span class="stringliteral">&#39;uint16_t&#39;</span>, cnt=len(elements), val=0x0, var_name=<span class="stringliteral">&#39;$elements&#39;</span>)</div><div class="line">    <span class="keywordflow">if</span> dott().target.byte_order == <span class="stringliteral">&#39;little&#39;</span>:</div><div class="line">        arr = (ctypes.c_int16 * 5)(*elements)</div><div class="line">    <span class="keywordflow">else</span>:</div><div class="line">        arr = (ctypes.c_int16.__ctype_be__ * 5)(*elements)</div><div class="line">    dott().target.mem.write(addr, bytes(arr))</div><div class="line">    res = dott().target.eval(f<span class="stringliteral">&#39;example_SumElements($elements, {len(elements)})&#39;</span>)</div><div class="line">    <span class="keyword">assert</span> (sum(elements) == res), f<span class="stringliteral">&#39;expected: {sum(elements)}, is: {res}&#39;</span></div></div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="ExampleFuncPointers"></a>
Function Pointer Arguments</h3>
<p>This example demonstrates how to to deal with target functions which take function pointers as arguments.</p>
<ul>
<li><p class="startli"><b>Target functions</b></p>
<p class="startli">On the target, two functions are defined taking two integer arguments, performing and addition or subtraction, and returning the result. A third function, <em>example_CustomOperation</em>, takes three arguments: A function pointer and two integer operands. It calls the function pointed two by the function pointer with the two integers as arguments and returns the result. </p><div class="fragment"><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function taking two arguments, adding the second to the first and returning</span></div><div class="line"><span class="comment"> * the result.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t __attribute__((used)) example_FunctorAdd(int32_t a, int32_t b)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> a + b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function taking two arguments, subtracting the second from the first and</span></div><div class="line"><span class="comment"> * returning the result.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t __attribute__((used)) example_FunctorSub(int32_t a, int32_t b)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> a - b;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function taking a function pointer and two integer arguments. It &#39;executes&#39;</span></div><div class="line"><span class="comment"> * the function pointed to by the pointer on the two arguments and returns the</span></div><div class="line"><span class="comment"> * result.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t __attribute__((used)) example_CustomOperation(int32_t (*func_ptr)(int32_t, int32_t), int32_t a, int32_t b)</div><div class="line">{</div><div class="line">    <span class="keywordflow">return</span> (*func_ptr)(a, b);</div><div class="line">}</div></div><!-- fragment --></li>
<li><p class="startli"><b>Host-side tests</b></p>
<p class="startli">On the host, a test is implemented which first gets the address of subtraction target function (<em>example_FunctorSub</em>). Next, it calls the target's <em>example_CustomOperation</em> function and passes this address as first argument and checks the result. It then performs the same steps with <em>example_FunctorAdd</em>. </p><div class="fragment"><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_CustomOperation(self, target_load, target_reset):</div><div class="line">    args = (44, 22)</div><div class="line">    exp_diff = args[0] - args[1]</div><div class="line">    exp_sum = sum(args)</div><div class="line"></div><div class="line">    func_sub_ptr = dott().target.eval(<span class="stringliteral">&#39;&amp;example_FunctorSub&#39;</span>)</div><div class="line">    res = dott().target.eval(f<span class="stringliteral">&#39;example_CustomOperation({func_sub_ptr}, {args[0]}, {args[1]})&#39;</span>)</div><div class="line">    assert(exp_diff == res), f<span class="stringliteral">&#39;expected: {exp_diff}, is: {res}&#39;</span></div><div class="line"></div><div class="line">    func_add_ptr = dott().target.eval(<span class="stringliteral">&#39;&amp;example_FunctorAdd&#39;</span>)</div><div class="line">    res = dott().target.eval(f<span class="stringliteral">&#39;example_CustomOperation({func_add_ptr}, {args[0]}, {args[1]})&#39;</span>)</div><div class="line">    assert(exp_sum == res), f<span class="stringliteral">&#39;expected: {exp_sum}, is: {res}&#39;</span></div></div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="ExampleInjection"></a>
Data Injection in Sub-calls</h3>
<p>An important part when testing is to inject well-defined data into the test execution. With DOTT this is possible by overriding the return values of functions which are called by other functions. Technically, this is done by setting breakpoints in these sub functions and altering the return values of these functions. This is illustrated in the following example.</p>
<ul>
<li><p class="startli"><b>Target functions</b></p>
<p class="startli">On the target, there is a function (<em>example_AdditionSubcalls</em>) performing an addition of two values which are supplied by two sub functions, <em>example_GetA</em> and <em>example_GetB</em>. Note that these two sub functions are marked with DOTT_NO_OPTIMIZE which prevents the compiler from optimizing out these two functions and hence making the example fail. More information on DOTT_NO_OPTIMIZE is provided in the <a href="DeveloperGuide.html">Developer's Guide</a>. </p><div class="fragment"><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Local function returning an integer.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> uint32_t __attribute__((used)) DOTT_NO_OPTIMIZE example_GetA(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t a = 42;</div><div class="line">    <span class="keywordflow">return</span> a;</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Local function returning an integer via pointer argument.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">static</span> uint32_t  __attribute__((used)) DOTT_NO_OPTIMIZE example_GetB(uint32_t *<span class="keyword">const</span> b)</div><div class="line">{</div><div class="line">    *b = 21;</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Function which calls two local functions to get the input for the computation.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">uint32_t __attribute__((used)) example_AdditionSubcalls(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    uint32_t a = example_GetA();</div><div class="line">    uint32_t b;</div><div class="line">    example_GetB(&amp;b);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> a + b;</div><div class="line">}</div></div><!-- fragment --></li>
<li><p class="startli"><b>Host-side tests</b></p>
<p class="startli">On the host, the first test calls the <em>exmaple_AdditionSubcalls</em> function without any injection. In the next test, two <b>InterceptPoints</b> are set up to intercept the two sub-functions <em>example_GetA</em> and <em>example_GetB</em>. </p><blockquote class="doxtable">
<p><b>Note:</b> An intercept point is a a special variant of a breakpoint. DOTT supports different types of breakpoints where not all of them can be used under all circumstances. Please check the Developer Guide for additional details. </p>
</blockquote>
<p class="startli">In the intercept points' <em>reached</em> methods the return values of the functions are altered. The intercept points are located at function entry. The calls to <em>ret()</em> let the functions return and hence the function bodies are not executed. Instances of the two intercept point classes are created and attached to the target functions. After calling <em>example_AdditionSubcalls</em> the return value reflects the data that was injected into the sub-functions. </p><div class="fragment"><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_AdditionSubcalls(self, target_load, target_reset):</div><div class="line">    res = dott().target.eval(<span class="stringliteral">&#39;example_AdditionSubcalls()&#39;</span>)</div><div class="line">    assert(63 == res)</div><div class="line"></div><div class="line"><span class="comment">##</span></div><div class="line"><span class="keyword">def </span>test_example_AdditionSubcallsExtIntercept(self, target_load, target_reset):</div><div class="line"></div><div class="line">    <span class="keyword">class </span>BpA(InterceptPoint):</div><div class="line">        <span class="keyword">def </span>reached(self):</div><div class="line">            self.ret(10)</div><div class="line"></div><div class="line">    <span class="keyword">class </span>BpB(InterceptPoint):</div><div class="line">        <span class="keyword">def </span>reached(self):</div><div class="line">            self.eval(<span class="stringliteral">&#39;*b = 89&#39;</span>)</div><div class="line">            self.eval(<span class="stringliteral">&#39;*b += 10&#39;</span>)   </div><div class="line">            val = self.eval(<span class="stringliteral">&#39;*b&#39;</span>)</div><div class="line">            assert(val == 99)</div><div class="line">            self.ret(0)</div><div class="line"></div><div class="line">    bpa = BpA(<span class="stringliteral">&#39;example_GetA&#39;</span>)</div><div class="line">    bpb = BpB(<span class="stringliteral">&#39;example_GetB&#39;</span>)</div><div class="line"></div><div class="line">    res = dott().target.eval(<span class="stringliteral">&#39;example_AdditionSubcalls()&#39;</span>)</div><div class="line"></div><div class="line">    bpa.delete()</div><div class="line">    bpb.delete()</div><div class="line"></div><div class="line">    assert(109 == res)</div></div><!-- fragment --> <blockquote class="doxtable">
<p><b>Note:</b> Using a DOTT_LABEL it is also be possible to perform the interception of the sub-functions not only on function entry but at arbitrary locations within the function. Please check the Developer Guide for additional details.</p>
</blockquote>
</li>
</ul>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.14
</small></address>
</body>
</html>
